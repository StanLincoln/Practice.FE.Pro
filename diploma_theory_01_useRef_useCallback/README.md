# README

## Теоретическое занятие №1

Репозитарий содержит материалы по проектному занятию №1, посвященному работе с хуками `useRef`, `useCallback`.

## Цели занятия
- закрепление знаний, полученных на лекции;
- разбор практических примеров;
- практическое применение полученных знаний.

### useRef
**Определение из документации:** `useRef` - хук, который возвращает нам ссылку (**reference**) на нечто, что не требуется при рендеринге.

**Определение для людей:** `useRef` - это хук, который позволяет нам создать объект-хранилище, в котором мы можем хранить все, что угодно (примитив, объект, массив, ссылку на DOM-узел), и этот объект переживет перерисовку компонента.

**Синтаксис**
```
export default function MyReactComponent(props) {
  const simpleRef = useRef(null); // значение аргумента - это начальное значение

  function getValueFromRef() {
    const valueFromRef = simpleRef.current; // у объекта-хранилища есть только одно свойство current, которое содержит значение
  }
  //...

  return (
    // Super JSX layout
  );
}
```

Сходство с `useState`:
 - значение в рефе "переживет" перерисовку компонента.

Отличия от `useState`:
 - свойство `current` мутабельное, то есть его можно перезаписывать.
 - при мутировании свойства `current`, компонент НЕ перерисовывается.

**Когда использовать рефы**?
 - если нам нужно работать с DOM-элементом (то есть нам нужна ПРЯМАЯ ссылка на РЕАЛЬНЫЙ DOM-элемент). Варианты применения:
   - управление фокусом
   - управление скроллом
   - анимации
   - видео
   - получение реальных параметров DOM-узла (ширина, высота, ...).
 - если нам нужно хранилище для чего-то, что должно пережить ререндер, но при этом изменение значения не должно провоцировать перерисовку компонента
 - для оптимизации производительности - если нам нужно, например, создать нечто ТОЛЬКО при первом рендере, и запомнить на всю оставшуюся жизнь компонента.

**Примеры** нужно (!) посмотреть в документации, ссылка на которую в блоке "Полезные ссылки".

### Задачи useRef
1. Пристрелочная задача. Реализовать подсчет кликов на кнопке в компоненте `DwarfForm`, при этом при изменении счетчика НЕ ПЕРЕРИСОВЫВАТЬ компонент.
2. Императивная работа с DOM-элементами. Добавить в компонент `DwarfForm` еще один инпут (номер телефона). Разместить его после существующих инпутов. Инпут НЕ РЕГИСТРИРОВАТЬ в `react-hook-form`. Нужно сделать так, чтобы при ПЕРВОМ рендере компонента `DwarfForm`, фокус становился на этот инпут. Тут нам тоже помогут рефы.
3. Еще работа с DOM. Нужно при клике на кнопку входа в компоненте `DwarfForm`, вывести в консоль актуальные ширину и высоту инпута для ввода номера телефона из п.2 (через свойствa `offsetWidth, offsetHeight` DOM-элемента).
4. Закрепление императивной работы с DOM. Нужно при нажатии на кнопку в компоненте `LoginForm`, выводить в консоль значение инпута "номер телефона". Сделать это БЕЗ использования `useState`, через рефы.
5. И теперь применим рефы в комбинации с `react-hook-form`. Нужно получить реф на инпут "Вооружение гнома", и при клике на кнопку, выводить в консоль ширину и высоту инпута.

### useCallback
**Определение из документации:** `useCallback` - хук, который позволяет закешировать определение функции меджду ререндерами.
На удивление, в этот раз определение из документации довольно "человекопонятное".

**Синтаксис**
```
export default function MyReactComponent(props) {
  const cachedFunction = useCallback( () => {
    // My awesome function
  }, []);

  //...

  return (
    // Super JSX layout
  );
}
```

**Когда использовать колбэки**
Их нужно использовать ТОЛЬКО для оптимизации производительности, в строго определенных случаях:
 - кэширование определения функции, которая передается в пропсах в дочерний "чистый" компонент
 - избежание слишком частого вызова эффекта, если в массиве зависимостей эффекта - функция, определенная в компоненте.
 - оптимизация кастомных хуков.

**React.memo** - это классное средство, которое позволяет ОБОЗНАЧИТЬ компонент как "чистый". Что есть "чистый" компонент: это компонент, который при одинаковых пропсах возвращает одинаковый результат рендеринга (т.е. зависит только от своих пропсов).

**Синтаксис**
```
function MyPureComponent(props) {
  return (
    // Super JSX layout
  );
}

export default memo(MyPureComponent); // компонент обозначен как "чистый".
```

### Задачи useCallback, React.memo
1. У нас есть компонент `CommonPage`. На нем есть инпут, в котором мы вводим данные, есть кнопка, и есть список "попыток". Каждый раз при вводе чего-то в инпут, компонент списка попыток перерисовывается. Исправьте это.
2. Добавьте возможность удаления попыток. Нужно сделать так, чтобы при клике на попытку в списке попыток, эта попытка удалялась.
3. Проверьте, не "сломалась" ли оптимизация (т.е. не перерисовывается ли компонент `AttemptsList` каждый раз при изменении инпута). Если сломалась - порассуждайте, почему так, и поправьте.

## Полезные ссылки по занятию:
 - [React useRef](https://react.dev/reference/react/useRef) - англоязычная документация по хуку `useRef`.
 - [Еще немного useRef](https://dmitripavlutin.com/react-useref/) - тоже англоязычное, и не особо простое для восприятия. Рекомендуется читать как минимум первую часть статьи.
 - [useCallback](https://react.dev/reference/react/useCallback#) - официальная документация
 - [Оптимизация через useCallback](https://habr.com/ru/articles/590577/) - русскоязычная, очень толковая информация - рекомендуется к прочтению!