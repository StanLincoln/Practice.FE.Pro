# README

## Теоретическое занятие №3

Репозитарий содержит материалы по проектному занятию №3, посвященному работе с юнит тестами, и библиотекой `Jest`.

### Unit тестирование
**Пирамида тестирования** - это абстрактное представление покрытия всего проекта тестами. Представляет собой пирамиду (странно, правда?), которая отображает разбивку тестов по уровням. Чем выше уровен в пирамиде, тем меньше количество таких тестов. В базовом варианте, состоит из 3 уровней:
 - unit-тесты. Самый нижний уровень, "фундамент" пирамиды. Юнит-тесты, или модульные тесты - это покрытие тестами модулей проекта (функций, компонентов, классов, ...). Их больше всего, они все автоматизированы. И это входит в обязанности разработчика.
 - integration-тесты. Средний уровень пирамиды. Это взаимодействие между компонентами (например, API, сервисы, логи на сервере и БД, ...).
 - end-to-end тесты, то есть тесты всей системы в целом. Это имитация действия пользователей.

В рамках наших занятий, мы будем говорить в основном о юнит-тестах.

Фронтендерам в написании юнит-тестов помогает библиотека `Jest`.

В случае разработки приложения с использованием `create-react-app`, библиотека `Jest` уже добавлена в зависимости проекта, и мы можем приступать к написанию тестов.

### Что и как тестировать
Обычно, в react-проектах покрывают тестами:
 - js-модули (вспомогательные функции, которые написаны на чистом JS)
 - react-компоненты
 - кастомные хуки

### Что такое тест
Если максимально упрощенно: тест - это запуск того, что тестируется с заданными параметрами/аргументами, и сравнение полученного результата с ожидаемым. Условно говоря, мы вызываем функцию с конкретными параметрами, и ожидаем от нее определенный возвращенный результат. Или мы просим отрендерить компонент с определенными пропсами, и ожидаем получить определенную разметку.

### Анатомия юнит-теста (для Jest)
Тест (`test case`) обычно содержит название теста (краткое описание, что же он проверяет), и функцию, которая должна выполнить определенные проверки. Тесты могут определяться в "пакеты", т.н. `Test Suites`.

### Как заставить все работать
С учетом того, что Jest уже добавлен в проект, нам не нужно делать никаких дополнительных настроек. Нужно просто начать писать наши тесты. Есть **правило именования** файлов с тестами: `ИМЯ_ТЕСТИРУЕМОГО_ФАЙЛА.test.РАСШИРЕНИЕ_ФАЙЛА`.

Пример: мы тестируем функциональность, описанную в файле `MathUtils.js`. тогда нам нужно создать файл `MathUtils.test.js`, и в нем описывать наши тесты.

Тогда, при запуске процесса автотестирования, Jest пройдется по каталогам проекта, и сам "подхватит" нужные файлы (с расширением `*.test.*`). Он это воспримет как тесты, и выполнит их.

### Пишем первые юнит тесты
Начнем с тестирования утилитарных JS-функций. Наша задача - покрыть тестами утилиты из файла src/utils/mathUtils/mathUtils.js. Создадим рядом файл `mathUtils.test.js`. В нем напишем наш первый тест.

```
// test - это зарезервированное имя тест кейса, которое будет подхвачено Jest.
test(
  'First test which checks the "add" function', // первый аргумент - это описание тест кейса
  () => { // второй аргумент - функция с самим юнит тестом
    const addResult = add(2,2); // вызываем нашу функцию, записываем результат в переменную
    expect(addResult).toBe(4); // сравниваем результат вызова нашей функции с ожидаемым значением
  }
);
```

Теперь попробуем прикинуть нештатные случаи.
 - передано не число
 - передан NaN (который является number)

Покроем и эти случаи тестами.
```
// test - это зарезервированное имя тест кейса, которое будет подхвачено Jest. Также можно использовать it
test(
  'Second test for "add" function: passing not a number',
  () => {
    const addResult = add('3',2);
    expect(addResult).toBe('something went wrong!');

    const addResult2 = add(NaN, 1);
    expect(addResult).toBe('something went wrong!');
  }
);
```

Получившийся код работает, но будет лучше объединить все это в тест-сьют. Давайте так и сделаем. Для этого есть функция `describe`.
```
describe(
  'Test "add" function,
  () => {
    it('Check number+number', () => {
      const result = addResult(2,2);
      expect(result).toBe(4);
    });
    it('Check non-number argument', () => {
      const result = addResult('2', 2);
      expect(result).toBe(''something went wrong!');
    });
    it('Check NaN argument', () => {
      const result = addResult(NaN, 2);
      expect(result).toBe(''something went wrong!');
    });
  }
)
```

Таким образом, получается пакет тестов для одной функции. Можно это записать еще короче:
```
describe(
  'Test "add" function',
  () => {
    const testsData = [
      { name: 'Check number+number', arg1: 2, arg2: 2, expected: 4 },
      { name: 'Check non-number argument', arg1: '2', arg2: 2, expected: 'something went wrong!' },
      { name: 'Check NaN argument', arg1: NaN, arg2: 2, expected: 'something went wrong!' },

    ];
    testsData.forEach( ({ name, arg1, arg2, expected }) => {
      it( name, () => {
        const result = add(arg1, arg2);
        expect(result).toBe(expected);
      })
    });
  }
)
```

### Закрепление практикой
Аналогичным образом, покройте оставшуюся функциональность тестами. Особое внимание - на деление.

### Работа с не-примитивами
Jest - умный фреймворк. Он может "разумно" работать с объектами - то есть при сравнении объектов/массивов, сравнивать их содержимое. Для этого, есть метод `toEqual`.
```
describe(
  'Test "duplicate" function',
  () => {
    it( 'Check numbers duplication', () => {
      expect(duplicate([1,2,3])).toEqual([2,4,6]);
    });

    it( 'Check strings duplication', () => {
      expect(duplicate(['1','2','3'])).toEqual(['11','22','33']);
    });
  }
);
```

Теперь напишите тест-сюьт для функции `getItemTypes`. Она принимает массив, и должна вернуть объект, который будет содержать кол-во свойств по типам (см.реализацию).


### Еще интересное по тест-кейсам
Jest умеет не только сравнивать, его возможности гораздо шире. Например, он может зафиксировать количество вызовов функции, проверить с какими аргументами вызвана функция, может отследить, что брошено исключение, может формировать неравенства, и многое другое. Рассмотрим пример с количеством вызовов функции. В файле `complexUtils`, есть функция `chooseCallback`. Она принимает два колбэка, и флаг, который определяет, какой колбэк выполнять. Напишем юнит-тесты для этой функции.
```
describe(
  'Test "chooseCallback" function',
  () => {
    it('Check first callback', () => {
      // Делаем т.н. "моки" - то есть липовые функции (заглушки)
      const firstCallback = jest.fn();
      const secondCallback = jest.fn();
      // вызываем нашу функцию, которую мы хотим протестировать
      chooseCallback(firstCallback, secondCallback, 'first');
      // проверяем, что первый колбэк был вызван хотя бы 1 раз
      expect(firstCallback).toBeCalled();
      // проверяем что второй колбэк не был вызван совсем
      expect(secondCallback).not.toBeCalled();
    });
  }
)
```

И для закрепления, покройте тестами `customForEach`.

## Полезные ссылки по занятию:
 - [Введение в Jest](https://www.youtube.com/watch?v=yLRVDM3_4_M) - отличное 40-минутное видео. Кратко, информативно, толково. Это про чистый Jest.
 - [Документация](https://jestjs.io/docs/getting-started) - англоязычная, не особо понятная, но все же документация. Рекомендуется использовать как справочник.